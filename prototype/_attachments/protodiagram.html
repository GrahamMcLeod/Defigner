<html>
  <head>
    <title>Force-Directed Layout</title>
    
    <script type="text/javascript" src="protovis-d3.2.js"></script>
     <script src="jquery.min.js"></script>
     <script src="jquery.tools.min.js"></script>
     <script src="myutils.js"></script>
     <script src="ICanHaz.min.js" ></script>
     <script src="thingstore.js"></script>
     <script src="dictionary.js"></script>
    
     <script id="outForm" type="text/html">      
{{#properties}}
{{label}}: {{value}}
{{/properties}}   
    </script>

    
    <style type="text/css">

body {
  margin: 0;
}

    </style>
  </head>
  <body>
  
  
    <script type="text/javascript+protovis">
  // Setup user information 
  var userInfo = {
    name: 'example_user',
    addUserInfo: function(thing) {
      thing.property('modified_by', this.name);
    },
    postMake: function(thing) {
      thing.property('last_modified', new Date());
      this.addUserInfo(thing);
    }
  };
  thingStore.userInfo(userInfo);
  dict = createDictionary(thingStore);
  var label = dict('label');
  var collection = dict('collection');
 
  // Define functions 
  // Fetch a collection of objects from the store using a named starting point and following 1 level of relationships 
  var fetchGraph = function (startURI, nodes, links) {
    var startNode = thingStore.lookup(startURI);
    var addNode = function(node) {
      var pos;
      var added = false;
      nodes.forEach(function(each, i) {
        if(each.uri == node.uri) {
          pos = i;
        }
      });
      if(!pos && (pos != 0)) {
        var tempNode = {
          nodeName: node.property(label), 
          thing: node,
          group: 1,
          uri: node.uri
        };
        var pos = nodes.push(tempNode)-1;
        added = true;
      }
      return {idx: pos, added: added};
    }
    var linkExists = function(source, target) {
      return (links.filter(function(each) {
        return ((each.source == source) && (each.target == target)) | ((each.source == target) && (each.target == source));
      }).length > 0)
    }
    var sourcePosInfo = addNode(startNode);
    var rels = startNode.properties().filter(function(each){return each.ofType(collection)});
    rels.forEach(function(rel) {
      startNode.property(rel).forEach(function(each) {
        var targetPosInfo = addNode(each);
        if(!linkExists(sourcePosInfo.idx, targetPosInfo.idx)) {
          var tempLink = {source: sourcePosInfo.idx, target:targetPosInfo.idx, value:1, relName: rel.property(label)};
          links.push(tempLink);
        }
      });
    });
  };
  // Convert logical view to HTML table structure
  var viewToHTML = function (view) {
      //return '<table>'+view+'</table>';
      // alert (JSON.stringify(view));
      var joinedList = view.properties.map (function (each){
        if(typeof each.value == 'object') {
          var list=each.value.map (function (e){
              return e.label
          }).join(', ');
          each.value=list;
          return each;                  
        }
        else {
        return each;
        }
      })
      view.properties=joinedList;
      return  ich.outForm(view,true);
  }
  
  // Initialise Panel
  // Render graph of retrieved objects on browser
  var renderGraph=function (startItem, tempNodes, tempLinks, update) {
    fetchGraph(startItem, tempNodes, tempLinks);
    var items = {
      nodes: tempNodes,
      links: tempLinks   
    };
    
    var w = document.body.clientWidth,
        h = document.body.clientHeight,
        colors = pv.Colors.category19();
    var vis = new pv.Panel()
         .width(w)
         .height(h)
         .fillStyle("white")
         .event("mousedown", pv.Behavior.pan())
         .event("mousewheel", pv.Behavior.zoom());  
          
    var force = vis.add(pv.Layout.Force)
        .nodes(items.nodes)
        .links(items.links)
        .springLength(200)
        .chargeConstant(-40)
        .springConstant(0.1);
    
    force.link.add(pv.Line)
         .add(pv.Label)
           .text(function (d, e) e.relName)
           .data(function(p) [{
                 x: (p.sourceNode.x + p.targetNode.x) / 2,
                 y: (p.sourceNode.y + p.targetNode.y) / 2
                 }]
                 )
           .textAlign("center")
           .textBaseline("middle");
           
    force.node.add(pv.Bar)
        .width(90)
        .height(20)
        .fillStyle(function(d)  {
          var nodeColour = colors(d.group);
          if (d.thing.isPrototype) {
            nodeColour = nodeColour.darker();}
          else {nodeColour = nodeColour.brighter()}; 
          return nodeColour
          })
        .strokeStyle(function() this.fillStyle().darker())
        .lineWidth(1)        
        .title(function(d) {
        //  return JSON.stringify(thingStore.lookup(d.uri))
        return viewToHTML (thingStore.lookup(d.uri).view())
        })
        .event("mousedown", pv.Behavior.drag())
        .event("click", function(d) {
          fetchGraph(d.uri, tempNodes, tempLinks);
          force.reset();
          force.nodes(tempNodes);
          force.links(tempLinks);
          force.render();
          // $("[title]").tooltip();
        })
        .event("drag", force)
        .anchor("center").add(pv.Label)
           .text( function (d) d.nodeName);
    vis.render();
   // $("[title]").tooltip();
  }
  // Initialise collections and set initial start item, then fetch data and render
  var startItem = 'uri:thing/person/graham';
  renderGraph (startItem, [], []);
    </script>
  </body>
</html>